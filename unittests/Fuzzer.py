from random import Random
from datetime import datetime, date, timedelta, MINYEAR, MAXYEAR


class Fuzzer(Random):
    """
    This class is dedicated to the generation of random python objects for testing purpose.
    Warning : randomness generated by this class is not cryptographically secure.
     ██████╗ ██████╗ ███╗   ██╗███████╗████████╗ █████╗ ███╗   ██╗████████╗███████╗
    ██╔════╝██╔═══██╗████╗  ██║██╔════╝╚══██╔══╝██╔══██╗████╗  ██║╚══██╔══╝██╔════╝██╗
    ██║     ██║   ██║██╔██╗ ██║███████╗   ██║   ███████║██╔██╗ ██║   ██║   ███████╗╚═╝
    ██║     ██║   ██║██║╚██╗██║╚════██║   ██║   ██╔══██║██║╚██╗██║   ██║   ╚════██║██╗
    ╚██████╗╚██████╔╝██║ ╚████║███████║   ██║   ██║  ██║██║ ╚████║   ██║   ███████║╚═╝
     ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝
    __WHITESPACE        = ' \t\n\r\v\f'
    __ASCII_LOWERCASE   = r'abcdefghijklmnopqrstuvwxyz'
    __ASCII_UPPERCASE   = r'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    __DIGITS            = '0123456789'
    __ASCII_LETTERS     = f"{__ASCII_LOWERCASE}{__ASCII_UPPERCASE}"
    __ASCII_ALPHANUM    = f"{__ASCII_LOWERCASE}{__ASCII_UPPERCASE}{__DIGITS}"
    __SPECIAL_CHARS     = r"!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"
    __PRINTABLE_CHARS   = f"{__DIGITS}{__ASCII_LOWERCASE}{__ASCII_UPPERCASE}{__SPECIAL_CHARS}{__WHITESPACE}"
    __ASCII_CHARS       = ''.join((chr(ascii_code) for ascii_code in range(256)))
    __IS_HASHABLE       = 0
    __IS_CONTAINER      = 1
    __IS_JSONABLE       = 2
    # \type: (is hashable, is a container, can be used in json format)
    __TYPES = \
        {
            None: (True, False, True),
            object: (True, False, False),
            bool: (True, False, True),
            int: (True, False, True),
            str: (True, False, True),
            float: (True, False, True),
            bytes: (True, False, False),
            bytearray: (False, False, False),
            complex: (True, False, False),
            BaseException: (True, False, False),
            list: (False, True, True),
            tuple: (True, True, False),
            set: (False, True, False),
            dict: (False, True, True),
            range: (True, True, False)
        }
    __HASHABLE_TYPES        = {type_: map_ for type_, map_ in __TYPES.items() if map_[0]}
    ██╗███╗   ██╗███████╗████████╗ █████╗ ███╗   ██╗ ██████╗███████╗    ██╗   ██╗ █████╗ ██████╗ ███████╗
    ██║████╗  ██║██╔════╝╚══██╔══╝██╔══██╗████╗  ██║██╔════╝██╔════╝    ██║   ██║██╔══██╗██╔══██╗██╔════╝██╗
    ██║██╔██╗ ██║███████╗   ██║   ███████║██╔██╗ ██║██║     █████╗      ██║   ██║███████║██████╔╝███████╗╚═╝
    ██║██║╚██╗██║╚════██║   ██║   ██╔══██║██║╚██╗██║██║     ██╔══╝      ╚██╗ ██╔╝██╔══██║██╔══██╗╚════██║██╗
    ██║██║ ╚████║███████║   ██║   ██║  ██║██║ ╚████║╚██████╗███████╗     ╚████╔╝ ██║  ██║██║  ██║███████║╚═╝
    ╚═╝╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝╚══════╝      ╚═══╝  ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝
    __seed_in_use           str|bytes|bytearray     The source of entropy. If None, current timestamp is used.
    __randomness_map        dict                    A dictionary of type {type: randomness_function}, for instance
                                                    {bool: lambda: bool(cls.randint(0, 1))}
    """

    # Copied (and improved) from string module (import string). This avoid to do an import just for that.
    __WHITESPACE = ' \t\n\r\v\f'
    __ASCII_LOWERCASE = r'abcdefghijklmnopqrstuvwxyz'
    __ASCII_UPPERCASE = r'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    __DIGITS = '0123456789'
    __ASCII_LETTERS = f"{__ASCII_LOWERCASE}{__ASCII_UPPERCASE}"
    __ASCII_ALPHANUM = f"{__ASCII_LOWERCASE}{__ASCII_UPPERCASE}{__DIGITS}"
    __SPECIAL_CHARS = r"""!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~"""
    __PRINTABLE_CHARS = f"{__DIGITS}{__ASCII_LOWERCASE}{__ASCII_UPPERCASE}{__SPECIAL_CHARS}{__WHITESPACE}"
    __ASCII_CHARS = ''.join((chr(ascii_code) for ascii_code in range(256)))

    __IS_HASHABLE = 0
    __IS_CONTAINER = 1
    __IS_JSONABLE = 2
    # \type: (is hashable, is a container, can be used in json format)
    __TYPES = \
        {
            None: (True, False, True),
            object: (True, False, False),
            bool: (True, False, True),
            int: (True, False, True),
            str: (True, False, True),
            float: (True, False, True),
            bytes: (True, False, False),
            bytearray: (False, False, False),
            complex: (True, False, False),
            BaseException: (True, False, False),
            datetime: (True, False, False),
            date: (True, False, False),
            timedelta: (True, False, False),
            list: (False, True, True),
            tuple: (True, True, False),
            set: (False, True, False),
            dict: (False, True, True),
            range: (True, True, False)
        }
    __HASHABLE_TYPES = {type_: map_ for type_, map_ in __TYPES.items() if map_[0]}

    __seed_in_use = None
    __randomness_map = None



    def __init__(self, seed=None) -> None:
        """
        Calls the random parent class, and setup the
        cls.__randomness_map before use.
        """
        super().__init__(seed)
        self.__seed_in_use = seed
        self.__randomness_map = \
            {
                None: lambda: None,
                object: lambda: object(),
                bool: lambda: bool(self.randint(0, 1)),
                int: lambda: self.logarithmic_randint(50),
                str: lambda: self.get_randstring(0, self.logarithmic_randint(5, True)),
                float: self.logarithmic_randfloat,
                bytes: lambda: self.randbytes(self.logarithmic_randint(5, True)),
                bytearray: lambda: bytearray(self.randbytes(self.logarithmic_randint(5, True))),
                complex: self.logarithmic_random_complex,
                BaseException: self.get_random_exception_object,
                datetime: self.get_random_datetime,
                date: lambda: self.get_random_datetime().date(),
                timedelta: lambda: self.get_random_datetime() - self.get_random_datetime(),
                list: self.get_random_list,
                tuple: self.get_random_tuple,
                set: self.get_random_set,
                dict: self.get_random_dict,
                range: lambda _1, _2, _3, _4: range
                (
                    self.logarithmic_randint(50),
                    self.logarithmic_randint(50),
                    (2*(self.randint(0, 1)) - 1) * (self.logarithmic_randint(50, True) + 1)
                )
            }
        return



    def __repr__(self) -> str:
        """
        Prints Fuzzer(seed=<seed>)
        >>> f = Fuzzer()
        >>> f
        Fuzzer(seed=None)
        """
        if isinstance(self.__seed_in_use, str):
            argument = f"\"{self.__seed_in_use}\""
        else:
            argument = self.__seed_in_use
        return f"{self.__class__.__name__}(seed={argument})"



    def get_random_datetime(self, min_year: int = MINYEAR, max_year: int = MAXYEAR) -> datetime:
        """
        @cls               Fuzzer          address of the current object (implicit parameter)
        @min_year           int             The minimum year. Default is datetime.MINYEAR = 1
        @max_year           int             The maximum year. Default is datetime.MAXYEAR = 9999
        @return             datetime        A random date between January, 1st, @min_year and
                                            December, 31th, @max_year
        Just get a completely random date (precision of millisecond)
        over the whole range of available date (0 <= year <= 9999)
        """
        return datetime\
            (
                self.randint(min_year, max_year),
                self.randint(1, 12),
                self.randint(1, 28),
                self.randint(0, 23),
                self.randint(0, 59),
                self.randint(0, 59),
                self.randint(0, 999999),
            )



    def get_randstring(self, min: int, max: int, charset: str = None, forbidden_chars: str = '') -> str:
        """
        @cls               Fuzzer          address of the current object (implicit parameter)
        @min                int             The minimum number of chars
        @max                int             The maximum number of chars
        @charset            str = None      The charset to chose in
        @forbidden_chars    str = ''        Chars to not include in the string.
        @return             str             A random string of random length
        This function returns a string of random length between @min and @max, composed of
        random chars among @charset with no chars in @forbidden_chars
        >>> f = Fuzzer()
        >>> f.get_randstring(3, 5, 'abcd')
        'bdcb'
        >>> f.get_randstring(3, 5, 'abcd', 'bcd')
        'aaaa'
        Warning : if charset is None (which is the case by default), the charset is set to
        the whole ASCII table.
        """
        if min == 0 and max == 0:
            return ''
        if min < 0 or max <= 0:
            raise ValueError('String length cannot be negative.')
        if charset is None:
            charset = self.__ASCII_CHARS
        if not forbidden_chars:
            return ''.join(self.choice(charset) for _ in range(1, self.randint(min + 1, max + 1)))
        for char in forbidden_chars:
            charset = charset.replace(char, '')
        return ''.join(self.choice(charset) for _ in range(1, self.randint(min + 1, max + 1)))



    def logarithmic_randint(self, max_number_of_digit: int = 50, absolute_value: bool = False) -> int:
        """
        @cls                   Fuzzer          address of the current object (implicit parameter)
        @max_number_of_digit    int             Maximum number of digit of generated integer
        @absolute_value         bool = False    Should the function return only positive integer?
        @return                 int             A random integer where small integers has same chances
                                                of selection than very huge ones.
        This function generates a random integer composed of @max_number_of_digit centered on zero.
        Each power of 10 ranges has the same probability to be chosen. In other words, if
        @max_number_of_digit = 5, an integers between [0 - 9] has the same chances to be chosen
        than an integer between [10000 - 99999]. This is achieved by generating a random string
        of @max_number_of_digit chars, containing only digits, and then convert it to an integer.
        """
        randint = int(self.get_randstring(1, max_number_of_digit, self.__DIGITS))
        if not absolute_value:
            randint = randint if bool(self.randint(0, 1)) else -1 * randint
        return randint



    def logarithmic_randfloat\
            (
                self,
                max_number_of_digit: int = 50,
                generate_nan: bool = True,
                generate_inf: bool = True,
                absolute_value: bool = False
            ) -> float:
        """
        @cls                   Fuzzer          address of the current object (implicit parameter)
        @max_number_of_digit    int             Maximum number of digit of the int part of generated float
        @absolute_value         bool = False    Should the function return only positive floats?
        @return                 float           A random float where small floats has same chances
                                                of selection than very huge ones.
        This function returns a random float where the integer portion is  composed of @max_number_of_digit
        centered on zero. Each power of 10 ranges has the same probability to be chosen. In other words, if
        @max_number_of_digit = 5, a float between [0 - 9] has the same chances to be chosen than a float
        between [10000 - 99999]. In fact, this function create a float by first generating a random integer
        through the function cls.logarithmic_randint, then it create a random float between [0 - 1[ through
        the random.uniform function, and it returns the sum of both.
        """
        random_integer = self.randint(0, 9)
        if random_integer == 0 and generate_inf:
            random_sign_if_applicable = (2 * (self.randint(0, 1) or absolute_value) - 1)
            return random_sign_if_applicable * float('inf')  # -inf or +inf
        if random_integer == 1 and generate_nan:
            return float('nan')
        return self.logarithmic_randint(max_number_of_digit, absolute_value) + self.uniform(0, 1)



    def logarithmic_random_complex\
            (
                self,
                max_number_of_digit: int = 50,
                type_of_real_part=None,
                type_of_imaginary_part=None
            ) -> complex:
        """
        @cls                       Fuzzer          address of the current object (implicit parameter)
        @max_number_of_digit        int     Maximum number of digit of the real and imaginary parts
        @type_of_real_part          type    Should the real part be an int or a float
        @type_of_imaginary_part     type    Should the imaginary part be an int or a float
        @return                     complex A complex number whereportions may be small or vey huge
        Generate a random complex through functions cls.logarithmic_randint and cls.logarithmic_randint.
        !!! WARNING !!! @type_of_real_part AND @type_of_imaginary_part expect a type, not an instance !
        The following code will raise a TypeError:
        >>> from Unittests.fuzzer import Fuzzer
        >>> f = Fuzzer()
        >>> f.logarithmic_random_complex(50, 2, 3.5)
        Traceback (most recent call last):
          File "<input>", line 1, in <module>
        TypeError: Arguments must be either type of None, int or float. type_of_part = int
        Correct use:
        >>> f.logarithmic_random_complex(50, int, float)
        (4630+636888011892.8619j)
        see also _Fuzzer__get_complex_part(), which is used to compute the real and imaginary portions.
        """
        real = self.__get_complex_part(max_number_of_digit, type_of_real_part)
        imaginary = self.__get_complex_part(max_number_of_digit, type_of_imaginary_part)
        return complex(real, imaginary)



    def __get_complex_part(self, max_number_of_digit: int, type_of_part) -> (int, float):
        """
        @cls                   Fuzzer          address of the current object (implicit parameter)
        @max_number_of_digit    int     Maximum number of digit of the real and imaginary parts
        @type_of_part           type    Should the real part be an int or a float
        @return                 int|float   A numeric value dedicated to be assigned to a complex portion
        Method called by cls.logarithmic_random_complex in order to compute the real
        and imaginary portion.
        If @type_of_part is type(int), then a random signed integer will be returned
        (generated through cls.logarithmic_randint).
        If it is @type_of_part is type(float), then a random signed float will be returned
        (generated through cls.logarithmic_randfloat).
        If @type_of_part is None, then return value type will be determined randomly, with
        same probabilities between integer and float.
        """
        if type_of_part not in {None, int, float}:
            raise TypeError(f"Arguments must be either type of None, int or float. type_of_part = {type_of_part}")
        if not type_of_part:
            complex_part = \
                self.logarithmic_randint(max_number_of_digit) \
                if bool(self.randint(0, 1)) \
                else self.logarithmic_randfloat(max_number_of_digit)
            return complex_part
        if type_of_part is int:
            return self.logarithmic_randint(max_number_of_digit)
        if type_of_part is float:
            return self.logarithmic_randfloat(max_number_of_digit)
        raise RuntimeError\
            (
                f"Error in function {self.__get_complex_part.__name__} in class {self.__class__.__name__}. "
                f"The execution flow has reached a point it should never fall into. "
                f"This is a logical mistake. A fix is needed."
            )



    def get_random_exception_object(self) -> BaseException:
        """
        @cls       Fuzzer          address of the current object (implicit parameter)
        @return     BaseException   A random exception with a random error message
        This method does the following:
            - Retrieves a list of all builtin python exception
            - Generate a random error message through cls.get_randstring() with a length
              generated through cls.logarithmic_randint() (So it may be very huge)
            - Select one randomly
            - Try to raise it, catch all and return the caught exception object
        """
        builtins = globals()['__builtins__']
        builtins = [item for item in builtins.values() if type(item) == type(BaseException)]
        builtins = [item for item in builtins if issubclass(item, BaseException)]
        error_message = self.get_randstring(0, self.logarithmic_randint(5, True))
        while True:
            error = self.choice(builtins)
            try:
                raise error(error_message)
            except BaseException as error:
                return error



    def get_random_object(self) -> object:
        """
        Takes a random class from cls.__TYPES and return
        an instance of this class. It do it by calling
        cls.get_random_list and returns the first element.
        """
        while True:
            try:
                return self.get_random_list(1)[0]
            except IndexError:
                continue



    def get_random_list\
            (
                self,
                max_number_of_elements: int = 100,
                deepness: int = 3,
                jsonable: bool = False,
                number_of_previous_calls: int = 0,
            ) -> list:
        """
        @cls                       Fuzzer      address of the current object (implicit parameter)
        @max_number_of_elements     int         max length of the returned list object
        @deepness                   int         Max level of nesting. For instance, if @deepness = 1,
                                                then, the returned list cannot contain containers objects.
                                                If deepness = 2, The returned list can have other lists,
                                                dictionaries, sets, and tuples inside, but those ones cannot.
        @jsonable                    bool       Can the retrieved list be converted into json?
        @number_of_previous_calls    int        Argument used to handle the recursion. Internal cooking.
                                                !!! DON'T TOUCH THIS ARGUMENT !!!
        @return                      list       A list containing random objects of any type
        Allows to retrieve a list of random length, with all kind of objects inside: integers, floats,
        complex, boolean, list, dictionaries, exceptions...
        !!! WARNING !!! This function may be very resources-consuming as it calls itself in order to
        create a list with other containers, with other containers inside, etc... If you set a too
        high value for @max_number_of_elements or @deepness, you may exhaust your computer's resources
        leading possibly to a crash. Be cautious.
        """
        if jsonable:
            filter = lambda type_: self.__TYPES[type_][self.__IS_JSONABLE]
        else:
            filter = lambda type_: True
        if number_of_previous_calls >= deepness:
            not_a_container_type = \
                {
                    type_: randomness_function
                    for type_, randomness_function in self.__randomness_map.items()
                    if not self.__TYPES[type_][self.__IS_CONTAINER] and filter(type_)
                }
            return [
                not_a_container_type[self.choice(tuple(not_a_container_type.keys()))]()
                for _ in range(self.randint(0, max_number_of_elements))
            ]

        # filling list with default element (often nul element), for instance 0 for int(0)
        l = \
        [
            self.choice(tuple([type_ for type_ in self.__TYPES.keys()
            if filter(type_)]))
            for _ in range(self.randint(0, max_number_of_elements))
        ]
        l2 = \
        [
            self.__randomness_map[type_]()
            if not self.__TYPES[type_][self.__IS_CONTAINER]
            else self.__randomness_map[type_](round(max_number_of_elements / 2), deepness, jsonable, number_of_previous_calls + 1)
            for type_ in l
        ]
        return l2



    def get_random_tuple\
        (
            self,
            max_number_of_elements: int = 100,
            deepness: int = 3,
            jsonable: bool = False,
            number_of_previous_calls: int = 0
        ) -> tuple:
        """
        @cls                       Fuzzer      address of the current object (implicit parameter)
        @max_number_of_elements     int         max length of the returned tuple object
        @deepness                   int         Max level of nesting. For instance, if @deepness = 1,
                                                then, the returned tuple cannot contain containers objects.
                                                If deepness = 2, The returned tuple can have other lists,
                                                dictionaries, sets, and tuples inside, but those ones cannot.
        @jsonable                    bool       Can the retrieved tuple be converted into json?
        @number_of_previous_calls    int        Argument used to handle the recursion. Internal cooking.
                                                !!! DON'T TOUCH THIS ARGUMENT !!!
        @return                      tuple      A tuple containing random objects of any type
        Convert a random list got through cls.get_random_list() into a tuple. See this method description.
        !!! WARNING !!! Same warning than cls.get_random_list()
        """
        return tuple(self.get_random_list(max_number_of_elements, deepness, jsonable, number_of_previous_calls))



    def get_random_hashable_tuple\
            (
                self,
                max_number_of_elements: int = 100,
                deepness: int = 3,
                jsonable: bool = False,
                number_of_previous_calls: int = 0
            ) -> tuple:
        """
        @cls                       Fuzzer      address of the current object (implicit parameter)
        @max_number_of_elements     int         max length of the returned tuple object
        @deepness                   int         Max level of nesting. For instance, if @deepness = 1,
                                                then, the returned tuple cannot contain containers objects.
                                                If deepness = 2, The returned tuple can have other lists,
                                                dictionaries, sets, and tuples inside, but those ones cannot.
        @jsonable                    bool       Can the retrieved tuple be converted into json?
        @number_of_previous_calls    int        Argument used to handle the recursion. Internal cooking.
                                                !!! DON'T TOUCH THIS ARGUMENT !!!
        @return                      tuple      A hashable tuple containing random objects of any type
        This method is quite similar to cls.get_random_tuple, but have a subtlety. In many python
        documentation, tuple are presented as immutable object. So one may suppose that as it is immutable,
        it is necessarily hashable and can be used in sets and as dictionary keys. This is wrong. A set
        is hashable if and only if it contains hashable object. And practically, the method cls.get_random_tuple
        generates non-hashable tuples (because they may contain lists and dictionaries which are mutable.
        So this is the purpose of this function. So as a consequence, tuples generated by this method
        DOES NOT contain any mutable objects.
        !!! WARNING !!! Same warning than cls.get_random_list()
        """
        if jsonable:
            filter = lambda type_: self.__TYPES[type_][self.__IS_JSONABLE]
        else:
            filter = lambda type_: True
        if number_of_previous_calls >= deepness:
            not_a_container_type = \
                {
                    type_: randomness_function
                    for type_, randomness_function in self.__randomness_map.items()
                    if self.__TYPES[type_][self.__IS_HASHABLE]
                       and filter(type_)
                       and not self.__TYPES[type_][self.__IS_CONTAINER]
                }
            return tuple([
                not_a_container_type[self.choice(tuple(not_a_container_type.keys()))]()
                for _ in range(self.randint(0, max_number_of_elements))
            ])

        custom_randomness_map = self.__randomness_map.copy()
        custom_randomness_map[tuple] = self.get_random_hashable_tuple

        # filling list with default element (often nul element), for instance 0 for int(0)
        l = \
            [
                self.choice(tuple([type_ for type_ in self.__HASHABLE_TYPES.keys()
                if filter(type_)]))
                for _ in range(self.randint(0, max_number_of_elements))
            ]
        l2 = \
            [
                custom_randomness_map[type_]()
                if not self.__TYPES[type_][self.__IS_CONTAINER]
                else custom_randomness_map[type_](round(max_number_of_elements / 2), deepness, jsonable, number_of_previous_calls + 1)
                for type_ in l
            ]
        return tuple(l2)



    def get_random_dict \
            (
                self,
                max_number_of_elements: int = 100,
                deepness: int = 3,
                jsonable: bool = False,
                number_of_previous_calls: int = 0
            ) -> dict:
        """
        @cls                       Fuzzer      address of the current object (implicit parameter)
        @max_number_of_elements     int         max length of the returned list object
        @deepness                   int         Max level of nesting. For instance, if @deepness = 1,
                                                then, the returned dict cannot contain containers objects.
                                                If deepness = 2, The returned dict can have other lists,
                                                dictionaries, sets, and tuples inside, but those ones cannot.
        @jsonable                    bool       Can the retrieved dictionary be converted into json?
        @number_of_previous_calls    int        Argument used to handle the recursion. Internal cooking.
                                                !!! DON'T TOUCH THIS ARGUMENT !!!
        @return                      dict       A dictionary containing random objects of any types both
                                                for keys and values.
        Allows to retrieve a dictionary of random length, with all kind of objects inside: integers, floats,
        complex, boolean, list, dictionaries, exceptions... bot as keys and value. Obviously, keys require
        hashable objects so keys are only composed of random immutable objects suc as numeric, tuples,
        exceptions, etc...
        !!! WARNING !!! This function may be very resources-consuming as it calls itself in order to
        create a dictionary with other containers, with other containers inside, etc... If you set a too
        high value for @max_number_of_elements or @deepness, you may exhaust your computer's resources
        leading possibly to a crash. Be cautious.
        """
        if jsonable:
            keys = [self.get_randstring(0, max_number_of_elements) for _ in range(max_number_of_elements)]
        else:
            keys = self.get_random_hashable_tuple(max_number_of_elements, deepness, jsonable, number_of_previous_calls)
        values = self.get_random_tuple(max_number_of_elements, deepness, jsonable, number_of_previous_calls)
        # No matter if keys and values are not of the same length.
        # Zip can handle it and the smallest iterable is the limiting factor.
        return {key: value for key, value in zip(keys, values)}



    def get_random_set \
            (
                self,
                max_number_of_elements: int = 100,
                deepness: int = 3,
                useless_argument = False,
                number_of_previous_calls: int = 0
            ) -> set:
        """
        @cls                       Fuzzer      address of the current object (implicit parameter)
        @max_number_of_elements     int         max length of the returned list object
        @deepness                   int         Max level of nesting. For instance, if @deepness = 1,
                                                then, the returned set cannot contain containers objects.
                                                If deepness = 2, The returned list can have other lists,
                                                dictionaries, sets, and tuples inside, but those ones cannot.
        @useless_argument            NoMatter   Argument here just for compatibility with other methods of this
                                                class. This argument is ignored by the method and is false by
                                                default. This argument is in fact the pending version of @jsonable
                                                for other container methods (for instance get_random_dict), but
                                                set are not jsonable (throw an error if trying to call json.dumps()
        @number_of_previous_calls    int        Argument used to handle the recursion. Internal cooking.
                                                !!! DON'T TOUCH THIS ARGUMENT !!!
        @return                      set        A set containing random hashable objects of any types
        This method returns a set of random length, composed of random hashable object (so immutable objects)
        (int, str, exceptions, etc...). In fact, it calls cls.get_random_hashable_tuple, and turn the
        resulting tuple into a set.
        !!! WARNING !!! Same warning than cls.get_random_list()
        """
        return set(self.get_random_hashable_tuple(max_number_of_elements, deepness, False, number_of_previous_calls))




#   ██████╗ ██████╗  ██████╗ ██████╗ ███████╗██████╗ ████████╗██╗███████╗███████╗
#   ██╔══██╗██╔══██╗██╔═══██╗██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██║██╔════╝██╔════╝
#   ██████╔╝██████╔╝██║   ██║██████╔╝█████╗  ██████╔╝   ██║   ██║█████╗  ███████╗
#   ██╔═══╝ ██╔══██╗██║   ██║██╔═══╝ ██╔══╝  ██╔══██╗   ██║   ██║██╔══╝  ╚════██║
#   ██║     ██║  ██║╚██████╔╝██║     ███████╗██║  ██║   ██║   ██║███████╗███████║
#   ╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═╝   ╚═╝   ╚═╝╚══════╝╚══════╝


    def __get_seed(self):
        return self.__seed_in_use

    def __set_seed(self, seed):
        self.seed(seed)
        self.__seed_in_use = seed
        return

    seed_in_use = property(fget=__get_seed, fset=__set_seed)

# ----------------------------------------------------------------------------------------------------------------------
    def __get_whitespace(self) -> str:
        return self.__WHITESPACE

    WHITESPACE = property(fget=__get_whitespace)

# ----------------------------------------------------------------------------------------------------------------------
    def __get_lowercase(self) -> str:
        return self.__ASCII_LOWERCASE

    ASCII_LOWERCASE = property(fget=__get_lowercase)

# ----------------------------------------------------------------------------------------------------------------------
    def __get_uppercase(self) -> str:
        return self.__ASCII_LOWERCASE

    ASCII_UPPERCASE = property(fget=__get_uppercase)

# ----------------------------------------------------------------------------------------------------------------------
    def __get_letters(self) -> str:
        return self.__ASCII_LETTERS

    ASCII_LETTERS = property(fget=__get_letters)

# ----------------------------------------------------------------------------------------------------------------------
    def __get_digits(self) -> str:
        return self.__DIGITS

    DIGITS = property(fget=__get_digits)

# ----------------------------------------------------------------------------------------------------------------------
    def __get_alphanum(self) -> str:
        return self.__ASCII_ALPHANUM

    ASCII_ALPHANUM = property(fget=__get_alphanum)

# ----------------------------------------------------------------------------------------------------------------------
    def __get_special_chars(self) -> str:
        return self.__SPECIAL_CHARS

    SPECIAL_CHARS = property(fget=__get_digits)

# ----------------------------------------------------------------------------------------------------------------------
    def __get_printable_chars(self) -> str:
        return self.__PRINTABLE_CHARS

    PRINTABLE_CHARS = property(fget=__get_printable_chars)

# ----------------------------------------------------------------------------------------------------------------------
    def __get_ascii_chars(self) -> str:
        return self.__PRINTABLE_CHARS

    ASCII_CHARS = property(fget=__get_ascii_chars)
